# Part A:

## Recovered password
User bjacobson has password "22005597"
User ceccio has password "02361267"

## Pseudocode for attack
My program is a brute force attack that iterates through numeric passwords of length 8 and hashing it 
until the result matches the given hash.

counter = 0
while hash match is not found:
    pad counter value with 0 until length of password
    format input string as "username,test_password,salt"
    get the hash result
    if the hashed password == given hash:
        return the padded counter value
    counter++

## Worst case running time
Worst case runtime would occur when the correct password is the last one tried. In the case of my 
iterative algorithm, that would occur if the password was 99999999. At that point, the algorithm
will have tried 10^n passwords, where n is password length. 
The hashing function is constant time O(1), so the number of iterations is the part that matters 
for the runtime. Thus worst-case asymptotic runtime is O(10^n), where n is password length.

## Discussion of current proposal and suggestions for improvement
The current proposal is good in the fact that it uses a salt. This means that password frequency in the 
password database cannot be found out since each password is appended with a different random value.
If 2 passwords are the same, the different salts will make their hashes appear different.
However, since hash functions are very fast, it is easy to brute for check every single password
until the correct one is found, like what my program did.
Therefore, an improvement would be to slow down the hash function. Instead of hashlib.sha256, 
hashlib.scrypt is a better hash function to use since it also uses memory, a costly resource, to slow
down the hashing, making brute force password cracking difficult. 
Another function that could be used is Argon2.

# Part B:

## Discussion of the current scheme
The current scheme uses encrypt-and-MAC, which is not secure. 

See line 35 of badencrypt.py:
    tag = hashlib.sha256(message.encode()).hexdigest()

Notice that the plaintext message is what's used to generate the tag, rather 
than the encrypted cyphertext. Thus the message tag can be forged because it 
does not require a key to create.

## Suggestions for improving the scheme
Use encrypt-then-MAC, which is secure.

Change line 35 of badencrypt.py to use the ciphertext:
    tag = hashlib.sha256(ciphertext.encode()).hexdigest()

Notice that we use the ciphertext to generate the tag, rather than the plaintext.
With this change, you need the key to create a valid tag. This way, an attacker 
with no knowledge of the key (like in this case) cannot forge a new tag.

# Part C:

## Secret code
3df46BC6-6e5a9f8c was one of the secret codes I recieved.

## Explanation
I act as the client side of the Diffie-Hellman Exchange procedure. First, I generate a secret key, x,
using the cryptography module. From that secret key, I create a public key g^x. Then I encode that key 
in base64 and send it through a HTTP GET request to the secret server, http://128.105.19.18:8080/dh.
The HTTP GET request will then send back a response that is a JSON object with 'c', a message 
encrypted with the shared key that contains the secret code, and gy, the public key for the server.
From the public key, I can get the shared key g^xy which will be used to decrypt the message 'c' 
and get the message and secret code. Finally, one more get request is sent to the server at 
http://128.105.19.18:8080/verify with the secret code. The response is then whether the secret
code is valid or not. 


